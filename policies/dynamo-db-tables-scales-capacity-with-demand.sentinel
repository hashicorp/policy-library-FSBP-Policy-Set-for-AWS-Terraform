# This policy requires that `aws_dynamodb_table` resources with 'billing_mode' attribute set to 'PROVISIONED'
# have autoscaling configured

# Imports

import "tfplan/v2" as tfplan
import "tfresources" as tf
import "report" as report
import "collection" as collection
import "collection/maps" as maps

# Params

# min_read_capacity specifies the minimum read capacity units for DynamoDB table auto-scaling targets.
param min_read_capacity default 1

# max_read_capacity specifies the maximum read capacity units for DynamoDB table auto-scaling targets.
param max_read_capacity default 40000

# min_write_capacity specifies the minimum write capacity units for DynamoDB table auto-scaling targets.
param min_write_capacity default 1

# max_write_capacity specifies the maximum write capacity units for DynamoDB table auto-scaling targets.
param max_write_capacity default 40000

# min_target_read_utilization specifies the minimum target utilization percentage for read auto-scaling policies.
param min_target_read_utilization default 20

# max_target_read_utilization specifies the maximum target utilization percentage for read auto-scaling policies.
param max_target_read_utilization default 90

# min_target_write_utilization specifies the minimum target utilization percentage for write auto-scaling policies.
param min_target_write_utilization default 20

# max_target_write_utilization specifies the maximum target utilization percentage for write auto-scaling policies.
param max_target_write_utilization default 90

# Constants
const = {
	"policy_name":                        "dynamo-db-tables-scales-capacity-with-demand",
	"resource_aws_dynamodb_table":        "aws_dynamodb_table",
	"resource_aws_appautoscaling_target": "aws_appautoscaling_target",
	"resource_aws_appautoscaling_policy": "aws_appautoscaling_policy",
}

# Functions
read_scaling_target_exists = func(read_scaling_targets, table) {
	return any read_scaling_targets as _, target {
		target.values.resource_id is "table/" + table.values.name and
			target.values.min_capacity >= min_read_capacity and
			target.values.max_capacity <= max_read_capacity
	}
}

write_scaling_target_exists = func(write_scaling_targets, table) {
	return any write_scaling_targets as _, target {
		target.values.resource_id is "table/" + table.values.name and
			target.values.min_capacity >= min_write_capacity and
			target.values.max_capacity <= max_write_capacity
	}
}

read_scaling_policy_exists = func(read_scaling_policies, table) {
	return any read_scaling_policies as _, policy {
		policy.values.resource_id is "table/" + table.values.name and
			maps.get(policy, "values.target_tracking_scaling_policy_configuration", []) is not empty and
			maps.get(policy.values.target_tracking_scaling_policy_configuration[0], "target_value", 0) >= min_target_read_utilization and
			maps.get(policy.values.target_tracking_scaling_policy_configuration[0], "target_value", 0) <= max_target_read_utilization
	}
}

write_scaling_policy_exists = func(write_scaling_policies, table) {
	return any write_scaling_policies as _, policy {
		policy.values.resource_id is "table/" + table.values.name and
			maps.get(policy, "values.target_tracking_scaling_policy_configuration", []) is not empty and
			maps.get(policy.values.target_tracking_scaling_policy_configuration[0], "target_value", 0) >= min_target_write_utilization and
			maps.get(policy.values.target_tracking_scaling_policy_configuration[0], "target_value", 0) <= max_target_write_utilization
	}
}

# Variables
planned_resources = tf.plan(tfplan.planned_values.resources)

# Filter for DynamoDB tables with PROVISIONED billing mode
dynamodb_tables = filter planned_resources.type(const.resource_aws_dynamodb_table).resources as _, resource {
	maps.get(resource, "values.billing_mode", "") is "PROVISIONED"
}

# Filter for auto-scaling targets for read capacity
read_scaling_targets = filter planned_resources.type(const.resource_aws_appautoscaling_target).resources as _, resource {
	maps.get(resource, "values.scalable_dimension", "") is "dynamodb:table:ReadCapacityUnits"
}

# Filter for auto-scaling targets for write capacity
write_scaling_targets = filter planned_resources.type(const.resource_aws_appautoscaling_target).resources as _, resource {
	maps.get(resource, "values.scalable_dimension", "") is "dynamodb:table:WriteCapacityUnits"
}

# Filter for auto-scaling policies for read capacity
read_scaling_policies = filter planned_resources.type(const.resource_aws_appautoscaling_policy).resources as _, resource {
	maps.get(resource, "values.target_tracking_scaling_policy_configuration", []) is not empty and maps.get(resource.values.target_tracking_scaling_policy_configuration[0], "predefined_metric_specification", []) is not empty and
		maps.get(resource.values.target_tracking_scaling_policy_configuration[0].predefined_metric_specification[0], "predefined_metric_type", "") is "DynamoDBReadCapacityUtilization"
}

# Filter for auto-scaling policies for write capacity
write_scaling_policies = filter planned_resources.type(const.resource_aws_appautoscaling_policy).resources as _, resource {
	maps.get(resource, "values.target_tracking_scaling_policy_configuration", []) is not empty and maps.get(resource.values.target_tracking_scaling_policy_configuration[0], "predefined_metric_specification", []) is not empty and
		maps.get(resource.values.target_tracking_scaling_policy_configuration[0].predefined_metric_specification[0], "predefined_metric_type", "") is "DynamoDBWriteCapacityUtilization"
}

violations = collection.reject(dynamodb_tables, func(table) {
	return read_scaling_target_exists(read_scaling_targets, table) and
		write_scaling_target_exists(write_scaling_targets, table) and
		read_scaling_policy_exists(read_scaling_policies, table) and
		write_scaling_policy_exists(write_scaling_policies, table)
})

summary = {
	"policy_name": const.policy_name,
	"violations": map violations as _, v {
		{
			"address":        v.address,
			"module_address": v.module_address,
			"message":        "Autoscaling is not enabled for 'aws_dynamodb_table' resources.Refer to https://docs.aws.amazon.com/securityhub/latest/userguide/dynamodb-controls.html#dynamodb-1 for more details.",
		}
	},
}

# Outputs

print(report.generate_policy_report(summary))

# Rules

main = rule {
	violations is empty
}
